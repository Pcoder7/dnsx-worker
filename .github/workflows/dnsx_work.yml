name: Parallel DNSX Recon

on:
  workflow_dispatch:

permissions:
  contents: write
  actions: write

jobs:
  prepare_matrix:
    runs-on: ubuntu-latest
    
    outputs:
      domains_json: ${{ steps.set_matrix.outputs.domains_json }}   
      
    steps:
      - name: Checkout private store-recon (other account)
        uses: actions/checkout@v3
        with:
          repository: pushrockzz/store-recon
          token: ${{ secrets.STORE_RECON_PAT }}
          path: store-recon
          fetch-depth: 0
      
      - name: Gather domain names with non-empty all_resolved.txt
        id: set_matrix
        run: |
          # For each store-recon/results/<domain>/all_resolved.txt that exists and is non-empty,
          # collect the "<domain>" folder name.
          mapfile -t domain_dirs < <(
            for f in $(find store-recon/results -maxdepth 2 -type f -name 'all_resolved.txt'); do
              # -s returns true if file size > 0
              if [ -s "$f" ]; then
                dirname=$(echo "$f" | awk -F/ '{print $3}')
                echo "$dirname"
              fi
            done | sort -u
          )

          if [ "${#domain_dirs[@]}" -eq 0 ]; then
            domains_json="[]"
          else
            domains_json=$(printf '%s\n' "${domain_dirs[@]}" \
              | jq -R -s -c 'split("\n") | map(select(length > 0))')
          fi

          echo "DEBUG: domains_json is: $domains_json"
          echo "domains_json=$domains_json" >> $GITHUB_OUTPUT     

      - name: Debug raw JSON
        run: echo "-> RAW domains_json ${{ steps.set_matrix.outputs.domains_json }}"        

  dnsx_recon:
    needs: prepare_matrix
    runs-on: ubuntu-latest
    if: ${{ needs.prepare_matrix.outputs.domains_json != '[]' }}
    env:
      LINES_PER_CHUNK: 1000 

    strategy:
      matrix:
        domain: ${{ fromJson(needs.prepare_matrix.outputs.domains_json) }}

    steps:
      - name: Checkout private store-recon (other account)
        uses: actions/checkout@v3
        with:
          repository: pushrockzz/store-recon
          token: ${{ secrets.STORE_RECON_PAT }}
          path: store-recon
          fetch-depth: 0

      - name:  Install dnsx tool
        run: |
          go install github.com/projectdiscovery/dnsx/cmd/dnsx@latest
          echo "$HOME/go/bin" >> $GITHUB_PATH

      - name: Prepare working directories for ${{ matrix.domain }}
        run: |
          
          DOMAIN="${{ matrix.domain }}"
          echo "Running DNSX recon for domain: $DOMAIN"
          mkdir -p work/${DOMAIN}
          mkdir -p results/${DOMAIN}
          

      - name: Copy all_resolved.txt for ${{ matrix.domain }}
        run: |

          DOMAIN="${{ matrix.domain }}"
          cp "store-recon/results/${DOMAIN}/all_resolved.txt" "work/${DOMAIN}/all_resolved.txt"

      - name: Split all_resolved.txt into chunks
        run: |
          # (Other variable assignments)
          total_lines=$(wc -l < "${INPUT_FILE}")
          
          # Use the environment variable LINES_PER_CHUNK, provide a default if it's not set
          # The :-1000 means if LINES_PER_CHUNK is unset or null, use 1000.
          # If it's set but empty, this might still be an issue for arithmetic,
          # but the job-level 'env' should prevent it from being empty.
          CURRENT_CHUNK_SIZE=${LINES_PER_CHUNK:-1000} 
          
          echo "DEBUG: Total lines in ${INPUT_FILE}: $total_lines"
          echo "DEBUG: LINES_PER_CHUNK from env: '${LINES_PER_CHUNK}'" # See what the env var actually is
          echo "DEBUG: Using CHUNK_SIZE: $CURRENT_CHUNK_SIZE"
          
          # Ensure total_lines is just the number, not leading spaces or filename
          # wc -l < file  should already give just the number.
          # But to be safe, especially if total_lines could have whitespace:
          total_lines_numeric=$(echo "$total_lines" | awk '{print $1}')
          
          if [ -z "$total_lines_numeric" ]; then
              echo "Error: Could not determine total lines from ${INPUT_FILE}."
              # Handle case where file is empty or wc -l failed
              # For an empty file, total_lines_numeric would be 0.
              # Let's assume if it's truly empty string, it's an error.
              # If file is empty, wc -l gives "0", so total_lines_numeric would be 0.
              # This check is more for if wc -l somehow failed and produced no output.
              # If the file doesn't exist, wc -l would print an error to stderr and 0 to stdout
              # The script should probably check if INPUT_FILE exists and is readable first.
              if [ ! -f "${INPUT_FILE}" ] || [ ! -r "${INPUT_FILE}" ]; then
                echo "Error: Input file ${INPUT_FILE} does not exist or is not readable."
                exit 1
              elif [ ! -s "${INPUT_FILE}" ]; then # If file is empty
                echo "Input file ${INPUT_FILE} is empty. Creating one empty chunk."
                touch "${CHUNKS_DIR}/chunk_01.txt" # Create an empty chunk
                total_lines_numeric=0 # Set to 0 explicitly for logic below
              else
                echo "Error: 'total_lines_numeric' is empty after processing wc -l output. This is unexpected."
                exit 1
              fi
          fi
          
          if [ "$total_lines_numeric" -le "$CURRENT_CHUNK_SIZE" ]; then
            # If total_lines is 0 (empty file) and CURRENT_CHUNK_SIZE is > 0, this condition is true.
            # So it will copy the (potentially empty) input file.
            cp "${INPUT_FILE}" "${CHUNKS_DIR}/chunk_01.txt"
          else
            split -l "$CURRENT_CHUNK_SIZE" -d --additional-suffix=".txt" \
              "${INPUT_FILE}" "${CHUNKS_DIR}/chunk_"
          fi

      - name: Run dnsx on each chunk (3 parallel jobs)
        run: |
          DOMAIN="${{ matrix.domain }}"
          CHUNKS_DIR="work/${DOMAIN}/chunks"
          OUT_DIR="work/${DOMAIN}/dnsx_out"
          mkdir -p "${OUT_DIR}"

          export DNSX_THREADS=50
          export DNSX_TIMEOUT=5s

          echo "Launching dnsx jobs in parallel (up to 3 at a time)..."
          ls "${CHUNKS_DIR}/chunk_"*.txt \
            | parallel -j 3 \
              'dnsx -l {} \
                -a -resp \
                -json \
                -o "'"${OUT_DIR}"'/dnsx_$(basename {}).json"'

      - name: Combine JSON outputs into single dnsx.json
        run: |
          DOMAIN="${{ matrix.domain }}"
          OUT_DIR="work/${DOMAIN}/dnsx_out"
          COMBINED="results/${DOMAIN}/dnsx.json"
          echo "Combining JSON files for $DOMAIN..."
          if ls "${OUT_DIR}"/dnsx_*.json 1> /dev/null 2>&1; then
            jq -s '.' "${OUT_DIR}"/dnsx_*.json > "${COMBINED}"
          else
            echo "[]" > "${COMBINED}"
          fi
          echo "Created combined JSON at ${COMBINED}"

      - name: Upload dnsx.json as artifact for ${{ matrix.domain }}
        uses: actions/upload-artifact@v4
        with:
          name: dnsx_${{ matrix.domain }}
          path: results/${{ matrix.domain }}/dnsx.json
          retention-days: 1

      - name: Commit and push dnsx.json back to store-recon
        run: |

          DOMAIN="${{ matrix.domain }}"
          SAFE_DOMAIN=$(echo "$DOMAIN" | tr '.' '_')
          TARGET_PATH="results/${DOMAIN}/dnsx.json"

          # Configure Git inside the checked‚Äêout store-recon folder
          cd store-recon
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          # Make sure we are on main and up-to-date
          git fetch origin main
          git checkout main
          git reset --hard origin/main

          # Copy the newly combined JSON from the workspace into store-recon's results/<domain>/
          mkdir -p "results/${DOMAIN}"
          cp "../results/${DOMAIN}/dnsx.json" "${TARGET_PATH}"

          git add "${TARGET_PATH}"
          if git diff --cached --quiet; then
            echo "No changes to dnsx.json for ${DOMAIN}; skipping commit."
            exit 0
          fi

          git commit -m "Add/update dnsx.json for ${DOMAIN}"

          # Push back using the PAT via HTTPS
          git remote set-url origin \
            https://x-access-token:${{ secrets.STORE_RECON_PAT }}@github.com/other-account/store-recon.git
          git push origin HEAD:main
